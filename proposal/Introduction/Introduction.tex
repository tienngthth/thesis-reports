\chapter[Introduction]{Introduction}

Compiler optimizations seek to improve program execution speed and overall performance, which can result in substantial cost savings for large-scale organizations, potentially reducing infrastructure expenses by millions annually. This project aims to assess the feasibility of implementing an optimizer in logic programming language within the GraalVM compiler framework. Specifically, this project examines the integration of GraalVM Ahead-of-Time (AOT) compiler optimizations with Prolog. The project works with AOT due to its advantages over Just-In-Time (JIT) compilation, which involves runtime code compilation that incurs higher overhead in terms of CPU and memory usage and introduces delays through dynamic optimization and profiling. In contrast, AOT compilation completes all compilation and optimizations at build time with minimal runtime overhead. 

Logic programming languages with declarative specifications allow programs to be analyzed efficiently through queries, enabling the implementation of code optimization that would otherwise be difficult to achieve. By focusing on what needs to be achieved rather than how to achieve it, declarative approaches offer greater clarity and intuitiveness. This inherent simplicity and readability facilitate the experimentation and development of new optimization rules, as well as the maintenance of existing ones. Additionally, declarative code is easier to debug, test, and ensure correctness because it is more straightforward and easier to follow. Previous research has extensively utilized Datalog, a prominent logic programming language, for different levels of program analysis \cite{Bravenboer2009,Tonder2021,Lam2005,Benton2007}. However, there is a notable lack of prior work regarding the application of logic programming languages for the optimization and transformation of code. Spinellis’ work in 1999 explored an alternative method for expressing optimizations through declarative specifications, as opposed to traditional imperative code \cite{Spinellis1999}. However, Spinellis’s work was limited to a rudimentary prototype of an optimizer with a ``single optimization specification" and ``limited flow-of-control optimizations" \cite{Spinellis1999}.

The proposed approach involves three main steps. First, optimization rules are defined as Prolog facts and predicates, focusing on canonicalization to standardize the IR code and conditional elimination to remove redundant expressions. Second, the Prolog fact generator parses the IR and converts it into Prolog facts, ensuring compatibility with optimization rules for effective query-based optimization. Finally, the Prolog-based optimizer is developed in Java to recursively query these rules, apply transformations, and refine the IR iteratively. As each optimization is applied, the IR is updated and reconstructed based on the optimized Prolog facts, leading to an improved representation of the program. To ensure correctness, a comprehensive test suite will be created to verify Prolog rule functionality, validate generated facts, and ensure the correctness of the optimized code. The performance will be evaluated based on execution speed, resource usage, and optimization throughput, alongside an assessment of whether Prolog’s declarative syntax improves optimization expressibility, documentation, comprehension, and maintenance.
