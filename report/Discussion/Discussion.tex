\chapter[Discussion]{Discussion}
This project successfully demonstrates the feasibility of integrating a Prolog engine into the GraalVM optimization pipeline using the Projog library. By translating GraalVMâ€™s IR nodes into Prolog terms and implementing optimization logic as Prolog predicate rules, the system is able to perform a variety of compiler optimizations in a declarative and modular fashion. The results confirm that Prolog can be used as a backend for expressing compiler optimizations, making this integration both technically viable and functionally complete.

One key strength of the Prolog-based approach is its expressiveness. The declarative nature of Prolog allows optimization rules such as those for AddNode canonicalization to be written in a concise and readable manner that closely mirrors their mathematical definitions. This makes the logic easier to reason about and verify. However, during development, writing and debugging Prolog rules proved more challenging compared to Java. Prolog lacks the rich tooling and step-by-step debugging support available in Java environments, and its inference-based execution model can make it harder to trace errors or unexpected outcomes. Additionally, some optimization tasks, particularly conditional elimination, were difficult to express in a purely declarative form. This is partly due to the structure of the IR graph, which lacks direct parent-child relationships, necessitating dynamic fact assertions to capture control flow relationships during analysis.

Developing the Prolog representation format presented several challenges that required iterative refinement. A key difficulty was managing the initial incompatibility between the node representation and the evolving design of the Prolog rules used for analysis and optimization. The representation needed to balance simplicity with expressiveness; for example, deciding whether a control-flow node like \texttt{if} should include only the identifiers of its condition and successors, or also embed more detailed structural information, such as the full definitions of those subnodes. These decisions were guided primarily by experimentation. Similarly, designing the Prolog result parser involved several challenges. First, deciding on a clear and expressive grammar that could accurately capture the variety of IR node structures was critical. The grammar needed to be both precise and flexible to handle recursive nesting and different term types. Ensuring extensibility was another key challenge; as new IR node types and optimization patterns evolved, the parser had to accommodate these changes without significant rewrites. The use of the visitor pattern was instrumental in overcoming this, as it cleanly separates parsing from IR reconstruction logic and allows node-specific behavior to be encapsulated and extended independently. Throughout development, an iterative improvement approach was adopted. The Prolog representation format, parser grammar, logic, and visitor methods were refined based as more rules were introduced. This approach enabled incremental validation across components, ensuring the overall robustness and maintainability of the parser.

In terms of performance, the impact of Prolog integration varies depending on the nature of the optimization. Stateless rules like those used for canonicalization perform well, with only minimal overhead. This is achieved by using a singleton Projog instance that loads rules once and reuses them across invocations. On the other hand, stateful optimizations such as conditional elimination show significant slowdowns. These optimizations require reinitializing the Prolog engine for each run because of the need to assert and retract dynamic facts such as stamps to track known variable values. As a result, rule loading and engine setup must be repeated frequently, causing noticeable degradation. Furthermore, the Projog engine is relatively slow and could potentially be faster; however, due to time constraints, exploring other Prolog engine options was not possible.

Looking forward, several improvements could be explored. Investigating alternative Prolog engines or approaches might help reduce overhead. Finding ways to express conditional elimination rules in a purely declarative manner without requiring dynamic assertion of facts would simplify the integration and improve performance. Finally, it would be worthwhile to explore other optimization domains that are particularly well suited to declarative logic, where Prolog's strengths in pattern matching and symbolic reasoning can be leveraged more effectively.