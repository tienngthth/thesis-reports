@article{Bravenboer2009,
   abstract = {We present the DOOP framework for points-to analysis of Java programs. DOOP builds on the idea of specifying pointer analysis algorithms declaratively, using Datalog: a logic-based language for defining (recursive) relations. We carry the declarative approach further than past work by describing the full end-to-end analysis in Datalog and optimizing aggressively using a novel technique specifically targeting highly recursive Datalog programs.},
   author = {Martin Bravenboer and Yannis Smaragdakis},
   doi = {10.1145/1639949.1640108},
   issn = {0362-1340},
   issue = {10},
   journal = {ACM SIGPLAN Notices},
   month = {Oct},
   pages = {243-262},
   publisher = {ACM Press},
   title = {Strictly declarative specification of sophisticated points-to analyses},
   volume = {44},
   url = {https://dl.acm.org/doi/10.1145/1639949.1640108},
   year = {2009},
}

@article{Tonder2021,
  author       = {Rijnard van Tonder},
  title        = {Towards Fully Declarative Program Analysis via Source Code Transformation},
  journal      = {CoRR},
  volume       = {abs/2112.12398},
  year         = {2021},
  url          = {https://doi.org/10.48550/arXiv.2112.12398},
  eprinttype    = {arXiv},
  eprint       = {2112.12398},
  timestamp    = {Tue, 04 Jan 2022 15:59:27 +0100},
  biburl       = {https://dblp.org/rec/journals/corr/abs-2112-12398.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{Lam2005,
   abstract = {Program analysis has been increasingly used in software engineering tasks such as auditing programs for security vulnerabilities and finding errors in general. Such tools often require analyses much more sophisticated than those traditionally used in compiler optimizations. In particular, context-sensitive pointer alias information is a prerequisite for any sound and precise analysis that reasons about uses of heap objects in a program. Context-sensitive analysis is challenging because there are over 10 14 contexts in a typical large program, even after recursive cycles are collapsed. Moreover, pointers cannot be resolved in general without analyzing the entire program. This paper presents a new framework, based on the concept of deductive databases, for context-sensitive program analysis. In this framework, all program information is stored as relations; data access and analyses are written as Datalog queries. To handle the large number of contexts in a program, the database represents relations with binary decision diagrams (BDDs). The system we have developed, called bddbddb, automatically translates database queries into highly optimized BDD programs. Our preliminary experiences suggest that a large class of analyses involving heap objects can be described succinctly in Data-log and implemented efficiently with BDDs. To make developing application-specific analyses easy for programmers, we have also created a language called PQL that makes a subset of Datalog queries more intuitive to define. We have used the language to find many security holes in Web applications.},
   author = {Monica S. Lam and John Whaley and V. Benjamin Livshits and Michael C. Martin and Dzintars Avots and Michael Carbin and Christopher Unkel},
   city = {New York, NY, USA},
   doi = {10.1145/1065167.1065169},
   isbn = {1595930620},
   booktitle = {Proceedings of the twenty-fourth ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems},
   month = {Jun},
   pages = {1-12},
   publisher = {ACM},
   title = {Context-sensitive program analysis as database queries},
   url = {https://dl.acm.org/doi/10.1145/1065167.1065169},
   year = {2005},
}

@inproceedings{Benton2007,
   author = {William C. Benton and Charles N. Fischer},
   city = {New York, NY, USA},
   doi = {10.1145/1273920.1273923},
   isbn = {9781595937698},
   booktitle = {Proceedings of the 9th ACM SIGPLAN international conference on Principles and practice of declarative programming},
   month = {Jul},
   pages = {13-24},
   publisher = {ACM},
   title = {Interactive, scalable, declarative program analysis},
   url = {https://dl.acm.org/doi/10.1145/1273920.1273923},
   year = {2007},
}

@article{Spinellis1999,
   abstract = {Peephole optimisation as a last step of a compilation sequence capitalises on significant opportunities for removing low level code slackness left over by the code generation process. We have designed a peephole optimiser that operates using a declarative specification of the optimisations to be performed. The optimiser's implementation is based on string pattern matching using regular expressions. We used this approach to prototype an optimiser to convert target machine instruction sequences containing conditional execution of instructions inside loop bodies into code that adaptively executes the optimum branch instructions according to the program's branch behaviour.},
   author = {Diomidis Spinellis},
   doi = {10.1145/307903.307921},
   issn = {0362-1340},
   issue = {2},
   journal = {ACM SIGPLAN Notices},
   keywords = {Peephole optimization,branch prediction,regular expressions},
   month = {Feb},
   pages = {47-50},
   title = {Declarative peephole optimization using string pattern matching},
   volume = {34},
   url = {https://dl.acm.org/doi/10.1145/307903.307921},
   year = {1999},
}

@article{Hagedorn2020,
  author       = {Bastian Hagedorn and
                  Johannes Lenfers and
                  Thomas Koehler and
                  Sergei Gorlatch and
                  Michel Steuwer},
  title        = {A Language for Describing Optimization Strategies},
  journal      = {CoRR},
  volume       = {abs/2002.02268},
  year         = {2020},
  url          = {https://doi.org/10.48550/arXiv.2002.02268},
  eprinttype    = {arXiv},
  eprint       = {2002.02268},
  timestamp    = {Tue, 10 May 2022 15:24:30 +0200},
  biburl       = {https://dblp.org/rec/journals/corr/abs-2002-02268.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@article{Jonathan2018,
   abstract = {Writing high-performance code on modern machines requires not just locally optimizing inner loops, but globally reorganizing computations to exploit parallelism and locality---doing things such as tiling and blocking whole pipelines to fit in cache. This is especially true for image processing pipelines, where individual stages do much too little work to amortize the cost of loading and storing results to and from off-chip memory. As a result, the performance difference between a naive implementation of a pipeline and one globally optimized for parallelism and locality is often an order of magnitude. However, using existing programming tools, writing high-performance image processing code requires sacrificing simplicity, portability, and modularity. We argue that this is because traditional programming models conflate the computations defining the algorithm with decisions about intermediate storage and the order of computation, which we call the schedule. },
   author = {Jonathan Ragan-Kelley and Andrew Adams and Dillon Sharlet and Connelly Barnes and Sylvain Paris and Marc Levoy and Saman Amarasinghe and Fr√©do Durand},
   doi = {10.1145/3150211},
   issn = {0001-0782},
   issue = {1},
   journal = {Communications of the ACM},
   month = {Dec},
   pages = {106-115},
   publisher = {Association for Computing Machinery},
   title = {Halide: decoupling algorithms from schedules for high-performance image processing},
   volume = {61},
   url = {https://dl.acm.org/doi/10.1145/3150211},
   year = {2017},
}

@inproceedings{Wade2017,
   abstract = {Just-in-time (JIT) compilation during program execution and ahead-of-time (AOT) compilation during software installation are alternate techniques used by managed language virtual machines (VM) to generate optimized native code while simultaneously achieving binary code portability and high execution performance. Profile data collected by JIT compilers at run-time can enable profile-guided optimizations (PGO) to customize the generated native code to different program inputs. AOT compilation removes the speed and energy overhead of online profile collection and dynamic compilation, but may not be able to achieve the quality and performance of customized native code. The goal of this work is to investigate and quantify the implications of the AOT compilation model on the quality of the generated native code for current VMs. First, we quantify the quality of native code generated by the two compilation models for a state-of-the-art (HotSpot) Java VM. Second, we determine how the amount of profile data collected affects the quality of generated code. Third, we develop a mechanism to determine the accuracy or similarity for different profile data for a given program run, and investigate how the accuracy of profile data affects its ability to effectively guide PGOs. Finally, we categorize the profile data types in our VM and explore the contribution of each such category to performance.},
   author = {April W. Wade and Prasad A. Kulkarni and Michael R. Jantz},
   city = {New York, NY, USA},
   doi = {10.1145/3078633.3081037},
   isbn = {9781450350303},
   issue = {5},
   booktitle = {Proceedings of the 18th ACM SIGPLAN/SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems},
   keywords = {Profile-guided optimizations,Program profiling},
   month = {Jun},
   pages = {1-10},
   publisher = {ACM},
   title = {{AOT} vs. {JIT}: impact of profile data on code quality},
   volume = {52},
   url = {https://dl.acm.org/doi/10.1145/3078633.3081037},
   year = {2017},
}

@inproceedings{Duboscq2013Inproceedings,
   abstract = {We present a compiler intermediate representation (IR) that allows dynamic speculative optimizations for high-level languages. The IR is graph-based and contains nodes fixed to control flow as well as floating nodes. Side-effecting nodes include a framestate that maps values back to the original program. Guard nodes dynamically check assumptions and, on failure, deoptimize to the interpreter that continues execution. Guards implicitly use the framestate and program position of the last side-effecting node. Therefore, they can be represented as freely floating nodes in the IR. Exception edges are modeled as explicit control flow and are subject to full optimization. We use profiling and deoptimization to speculatively reduce the number of such edges. The IR is the core of a just-in-time compiler that is integrated with the Java HotSpot VM. We evaluate the design decisions of the IR using major Java benchmark suites. Copyrightc 2013 ACM.},
   author = {Gilles Duboscq and Thomas W√ºrthinger and Lukas Stadler and Christian Wimmer and Doug Simon and Hanspeter M√∂ssenb√∂ck},
   city = {New York, NY, USA},
   doi = {10.1145/2542142.2542143},
   isbn = {9781450326018},
   booktitle = {Proceedings of the 7th ACM workshop on Virtual machines and intermediate languages},
   keywords = {Intermediate representation,Java virtual machine,Just-in-time compilation,Speculative optimization},
   month = {Oct},
   pages = {1-10},
   publisher = {ACM},
   title = {An intermediate representation for speculative optimizations in a dynamic compiler},
   url = {https://dl.acm.org/doi/10.1145/2542142.2542143},
   year = {2013},
}

@inproceedings{Graal2021,
   abstract = {Contemporary software often becomes vastly complex, and we are required to use a variety of technologies and different programming languages for its development. As interoperability between programming languages could cause high overhead resulting in a performance loss, it is important to examine how a current polyglot virtual machine with a compiler written in a high-level object-oriented language deals with it. OpenJDK's Project Metropolis presented the GraalVM, an open-source, high-performance polyglot virtual machine, mostly written in Java. This paper presents GraalVM's architecture and its features; furthermore, examining how it resolves common interoperability and performance problems. GraalVM makes software ecosystem productive when combining various programming languages, for example, Java, JavaScript, C/C++, Python, Ruby, R, and others. The vital part of GraalVM is the Graal compiler written in Java, which allows developers to maintain and optimize code faster, simpler, and more efficient, in comparison to traditional compilers in C/C++ languages. Graal can be used as a just-in-time (JIT) or as static, ahead-of-time (AOT) compiler. Graal is an aggressively optimizing compiler implementing common compiler optimizations, with emphasis on outstanding inlining and escape analysis algorithms. This paper compares Graal with some of the best-specialized competitors, and presents our results tested within an academic environment.},
   author = {M. Sipek and B. Mihaljevic and A. Radovan},
   doi = {10.23919/MIPRO.2019.8756917},
   isbn = {978-953-233-098-4},
   booktitle = {2019 42nd International Convention on Information and Communication Technology, Electronics and Microelectronics (MIPRO)},
   keywords = {Graal,GraalVM,Java,Java Virtual Machine,cross-language interoperability,polyglot virtual machine,programming languages},
   month = {May},
   pages = {1671-1676},
   publisher = {IEEE},
   title = {Exploring Aspects of Polyglot High-Performance Virtual Machine {GraalVM}},
   url = {https://ieeexplore.ieee.org/document/8756917/},
   year = {2019},
}
@inproceedings{Cliff1995,
   author = {Cliff Click},
   city = {New York, NY, USA},
   doi = {10.1145/207110.207154},
   isbn = {0897916972},
   booktitle = {Proceedings of the ACM SIGPLAN 1995 conference on Programming language design and implementation},
   month = {Jun},
   pages = {246-257},
   publisher = {ACM},
   title = {Global code motion/global value numbering},
   url = {https://dl.acm.org/doi/10.1145/207110.207154},
   year = {1995},
}

@inproceedings{Duboscq2013,
   abstract = {We present an intermediate representation (IR) for a Java just in time (JIT) compiler written in Java. It is a graph-based IR that models both control-flow and data-flow dependencies between nodes. We show the framework in which we developed our IR. Much care has been taken to allow the programmer to focus on compiler optimization rather than IR bookkeeping. Edges between nodes are declared concisely using Java annotations, and common properties and functions on nodes are communicated to the framework by implementing interfaces. Building upon these declarations, the graph framework automatically implements a set of useful primitives that the programmer can use to implement optimizations .},
   title={Graal {IR}: An Extensible Declarative Intermediate Representation},
   author = {Gilles Duboscq and Lukas Stadler and Thomas W√ºrthinger and Doug Simon and Christian Wimmer and Hanspeter M√∂ssenb√∂ck},
   year={2013},
   url={https://api.semanticscholar.org/CorpusID:52231504},
   booktitle={2nd Asia-Pacific Programming Languages and Compilers}
}

@inproceedings{Ron1991,
   author = {B. K. Rosen and M. N. Wegman and F. K. Zadeck},
   city = {New York, New York, USA},
   doi = {10.1145/73560.73562},
   isbn = {0897912527},
   booktitle = {Proceedings of the 15th ACM SIGPLAN-SIGACT symposium on Principles of programming languages  - POPL '88},
   pages = {12-27},
   publisher = {ACM Press},
   title = {Global value numbers and redundant computations},
   url = {https://dl.acm.org/doi/10.1145/73560.73562},
   year = {1988},
}

@article{Wimmer2019,
   abstract = {Arbitrary program extension at run time in language-based VMs, e.g., Java's dynamic class loading, comes at a startup cost: high memory footprint and slow warmup. Cloud computing amplifies the startup overhead. Microservices and serverless cloud functions lead to small, self-contained applications that are started often. Slow startup and high memory footprint directly affect the cloud hosting costs, and slow startup can also break service-level agreements. Many applications are limited to a prescribed set of pre-tested classes, i.e., use a closed-world assumption at deployment time. For such Java applications, GraalVM Native Image offers fast startup and stable performance.},
   author = {Christian Wimmer and Codrut Stancu and Peter Hofer and Vojin Jovanovic and Paul W√∂gerer and Peter B. Kessler and Oleg Pliss and Thomas W√ºrthinger},
   doi = {10.1145/3360610},
   issn = {2475-1421},
   issue = {OOPSLA},
   journal = {Proceedings of the ACM on Programming Languages},
   keywords = {Ahead-of-time compilation,Compiler,Graal,GraalVM,Java,Optimization,Virtual machine},
   month = {Oct},
   pages = {1-29},
   publisher = {Association for Computing Machinery},
   title = {Initialize once, start fast: application initialization at build time},
   volume = {3},
   url = {https://dl.acm.org/doi/10.1145/3360610},
   year = {2019},
}

@inproceedings{Webb2023,
   abstract = {Our objective is to formally verify the correctness of the hundreds of expression optimization rules used within the GraalVM compiler. When defining the semantics of a programming language, expressions naturally form abstract syntax trees, or, terms. However, in order to facilitate sharing of common subexpressions, modern compilers represent expressions as term graphs. Defining the semantics of term graphs is more complicated than defining the semantics of their equivalent term representations. More significantly, defining optimizations directly on term graphs and proving semantics preservation is considerably more complicated than on the equivalent term representations. On terms, optimizations can be expressed as conditional term rewriting rules, and proofs that the rewrites are semantics preserving are relatively straightforward. In this paper, we explore an approach to using term rewrites to verify term graph transformations of optimizations within the GraalVM compiler. This approach significantly reduces the overall verification effort and allows for simpler encoding of optimization rules.},
   author = {Brae J. Webb and Ian J. Hayes and Mark Utting},
   city = {New York, NY, USA},
   doi = {10.1145/3573105.3575673},
   isbn = {9798400700262},
   booktitle = {Proceedings of the 12th ACM SIGPLAN International Conference on Certified Programs and Proofs},
   keywords = {GraalVM compiler,{Isabelle/HOL},sea-of-nodes intermediate representation,verified code optimizer},
   month = {Jan},
   pages = {320-333},
   publisher = {ACM},
   title = {Verifying Term Graph Optimizations using {Isabelle/HOL}},
   url = {https://dl.acm.org/doi/10.1145/3573105.3575673},
   year = {2023},
}

@article{Pinet2022,
   abstract = {Data warehouses have demonstrated their applicability in numerous application fields such as agriculture, the environment and health. This paper proposes a general framework for defining a data warehouse and its aggregations using logic programming. The objective is to show that data managers can easily express, in Prolog, traditional data warehouse queries and combine data aggregation operations with other advanced Prolog features. It is shown that this language provides advanced features to aggregate information in an in-memory database. This paper targets data managers; it shows them the direct writing of data warehouse queries in Prolog using an easily understandable syntax. The queries are not necessarily in an optimal form from a processing point of view, but a data manager can easily use or write them.},
   author = {Fran√ßois Pinet},
   doi = {10.3390/app122111223},
   issn = {20763417},
   issue = {21},
   journal = {Applied Sciences (Switzerland)},
   keywords = {data aggregation,data warehouse,prolog},
   month = {Nov},
   publisher = {MDPI},
   title = {Brief Report on the Advanced Use of Prolog for Data Warehouses},
   volume = {12},
   year = {2022},
}

@inproceedings{Prokopec2017,
   abstract = {Functional collection combinators are a neat and widely accepted data processing abstraction. However, their generic nature results in high abstraction overheads - Scala collections are known to be notoriously slow for typical tasks. We show that proper optimizations in a JIT compiler can widely eliminate overheads imposed by these abstractions. Using the open-source Graal JIT compiler, we achieve speedups of up to 20√ó on collection workloads compared to the standard HotSpot C2 compiler. Consequently, a sufficiently aggressive JIT compiler allows the language compiler, such as Scalac, to focus on other concerns. In this paper, we show how optimizations, such as inlining, polymorphic inlining, and partial escape analysis, are combined in Graal to produce collections code that is optimal with respect to manually written code, or close to optimal. We argue why some of these optimizations are more effectively done by a JIT compiler. We then identify specific usecases that most current JIT compilers do not optimize well, warranting special treatment from the language compiler.},
   author = {Aleksandar Prokopec and Gilles Duboscq and David Leopoldseder and Thomas W√ºrthinger},
   doi = {10.1145/3136000.3136002},
   isbn = {9781450355292},
   booktitle = {SCALA 2017 - Proceedings of the 8th ACM SIGPLAN International Symposium on Scala, co-located with SPLASH 2017},
   keywords = {Collections,Data-parallelism,Filterators,Functional combinators,Inlining,JIT compilation,Partial escape analysis,Program optimization,Scalar replacement},
   month = {Oct},
   pages = {29-40},
   publisher = {Association for Computing Machinery, Inc},
   title = {Making collection operations optimal with aggressive JIT compilation},
   year = {2017},
}

@incollection{Bramer2013,
   author="Bramer, Max",
   title="Clauses and Predicates",
   booktitle="Logic Programming with Prolog",
   year="2013",
   publisher="Springer London",
   address="London",
   pages="13--27",
   abstract="This chapter introduces the two types of Prolog clause, namely facts and rules and their components. It also introduces the concept of a predicate and describes different features of variables.",
   isbn="978-1-4471-5487-7",
   doi="10.1007/978-1-4471-5487-7_2",
   url="https://doi.org/10.1007/978-1-4471-5487-7_2",
}

@incollection{Chowdhary2020,
   author="Chowdhary, K. R.",
   title="Logic Programming and Prolog",
   booktitle="Fundamentals of Artificial Intelligence",
   year="2020",
   publisher="Springer India",
   address="New Delhi",
   pages="111--141",
   abstract="PrologLogic programmingProlog¬†is logic programming languages for AI, based on predicate logic. This chapter discusses the structure, syntax, and semantics of Prolog language, provides comparison with procedural language like C, interpretation of predicate logic and that of Prolog, both formally as well through worked out examples, and explain how the recursion is definition as well solution of a problem, and explains with simple examples as how the control sequencing takes place in Prolog. Use of two open source compilers of prolog using simple worked out examples is demonstrated. Each concept of Prolog and logic programming is explained with the help of worked out examples. At the end, a brief summary gives glimpse of the chapter, followed with number of exercises to strengthen the learning.",
   isbn="978-81-322-3972-7",
   doi="10.1007/978-81-322-3972-7_5",
   url="https://doi.org/10.1007/978-81-322-3972-7_5",
   chapter="5",
   pages="111‚Äì141"
}

@inproceedings{Eelco2001,
   author="Visser, Eelco",
   editor="Middeldorp, Aart",
   title="Stratego: A Language for Program Transformation Based on Rewriting Strategies System Description of {Stratego} 0.5",
   booktitle="Rewriting Techniques and Applications",
   year="2001",
   publisher="Springer Berlin Heidelberg",
   address="Berlin, Heidelberg",
   pages="357--361",
   abstract="Program transformation is used in many areas of software engineering. Examples include compilation, optimization, synthesis, refactoring, migration, normalization and improvement [15]. Rewrite rules are a natural formalism for expressing single program transformations. However, using a standard strategy for normalizing a program with a set of rewrite rules is not adequate for implementing program transformation systems. It may be necessary to apply a rule only in some phase of a transformation, to apply rules in some order, or to apply a rule only to part of a program. These restrictions may be necessary to avoid non-termination or to choose a specific path in a non-con uent rewrite system.",
   isbn="978-3-540-45127-3",
   url="https://doi.org/10.1007/3-540-45127-7_27"
}

@article{silverman2021wantanalyzeschemeprograms,
  author       = {Davis Ross Silverman and
                  Yihao Sun and
                  Kristopher K. Micinski and
                  Thomas Gilray},
  title        = {So You Want to Analyze Scheme Programs With Datalog?},
  journal      = {CoRR},
  volume       = {abs/2107.12909},
  year         = {2021},
  url          = {https://doi.org/10.48550/arXiv.2107.12909},
  eprinttype    = {arXiv},
  eprint       = {2107.12909},
  timestamp    = {Fri, 30 Jul 2021 13:03:06 +0200},
  biburl       = {https://dblp.org/rec/journals/corr/abs-2107-12909.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}
