\chapter[Conclusion]{Conclusions}
This project successfully demonstrated the feasibility of integrating Prolog-based optimization techniques into the GraalVM compiler framework. By converting GraalVM’s intermediate representation into Prolog terms and expressing optimizations as declarative rules, it was possible to implement a functional optimization pipeline within GraalVM using Projog. The results show that Prolog’s declarative syntax offers clear and expressive rule definitions, particularly well suited for stateless optimizations like canonicalization.

However, performance limitations were observed, especially for stateful optimizations such as conditional elimination. These phases suffered from significant overhead due to repeated engine initialization and dynamic fact management in Projog. While stateless optimizations incurred only minimal overhead thanks to reuse of a singleton Prolog instance, stateful optimizations were substantially slower. Additionally, the Projog engine itself proved relatively slow, and time constraints prevented exploring alternative Prolog implementations that might offer better performance.

Despite these challenges, the project highlights the potential of leveraging logic programming for compiler optimizations. The declarative nature of Prolog facilitates reasoning about optimization rules and modularizes the optimization logic. Future work could focus on identifying more performant Prolog engines, devising purely declarative methods for complex transformations like conditional elimination, and exploring other compiler optimization domains that can benefit from Prolog’s strengths in symbolic reasoning and pattern matching.

